<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D风格迷宫生成器</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&family=Roboto:wght@300;400&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4361ee;
            --secondary-color: #3f37c9;
            --accent-color: #4895ef;
            --light-color: #f8f9fa;
            --dark-color: #212529;
            --success-color: #4cc9f0;
            --danger-color: #f72585;
            --wall-color: #3a0ca3;
            --path-color: #4cc9f0;
            --player-color: #f72585;
            --exit-color: #38b000;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Roboto', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%);
            color: var(--dark-color);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .container::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color), var(--success-color));
        }
        
        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 30px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 2.5rem;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
            position: relative;
            padding-bottom: 15px;
        }
        
        h1::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            border-radius: 2px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background-color: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .control-group:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        }
        
        .control-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: var(--primary-color);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        select, input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-family: 'Roboto', sans-serif;
            font-size: 1rem;
            transition: all 0.3s;
            background-color: white;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }
        
        .color-inputs {
            display: flex;
            gap: 10px;
        }
        
        .color-inputs input[type="color"] {
            flex: 1;
            padding: 5px;
            height: 50px;
            cursor: pointer;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        
        button {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: 8px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        button i {
            font-size: 1.2rem;
        }
        
        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .btn-primary:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(67, 97, 238, 0.3);
        }
        
        .btn-secondary {
            background-color: white;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
        }
        
        .btn-secondary:hover {
            background-color: #f0f4ff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(67, 97, 238, 0.1);
        }
        
        .btn-success {
            background-color: var(--success-color);
            color: white;
        }
        
        .btn-success:hover {
            background-color: #3aa8d8;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 201, 240, 0.3);
        }
        
        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #e5177b;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(247, 37, 133, 0.3);
        }
        
        .btn-warning {
            background-color: #ff9e00;
            color: white;
        }
        
        .btn-warning:hover {
            background-color: #e68a00;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 158, 0, 0.3);
        }
        
        .game-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .game-info {
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
            color: var(--primary-color);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .maze-container {
            position: relative;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .maze-container::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 10px;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color), var(--success-color));
        }
        
        canvas {
            background-color: white;
            border-radius: 10px;
            max-width: 100%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .mobile-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
            width: 100%;
            max-width: 300px;
        }
        
        .mobile-controls button {
            height: 60px;
            font-size: 1.5rem;
        }
        
        .keyboard-hint {
            text-align: center;
            margin-top: 15px;
            font-size: 0.9rem;
            color: #6c757d;
            display: none;
        }
        
        .footer {
            text-align: center;
            margin-top: 20px;
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .mobile-controls {
                display: grid;
            }
            
            .keyboard-hint {
                display: none;
            }
            
            .game-controls {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .button-group {
                flex-direction: column;
            }
        }
        
        @media print {
            .no-print {
                display: none;
            }
            
            canvas {
                border: none;
                box-shadow: none;
                max-width: 100%;
                max-height: 100vh;
            }
            
            body {
                background: none;
                padding: 0;
            }
            
            .container {
                box-shadow: none;
                padding: 0;
                max-width: 100%;
            }
        }
        
        /* 动画效果 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .container {
            animation: fadeIn 0.5s ease-out;
        }
        
        /* 3D按钮效果 */
        .btn-3d {
            position: relative;
            box-shadow: 0 5px 0 0 rgba(0, 0, 0, 0.2);
        }
        
        .btn-3d:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 0 rgba(0, 0, 0, 0.2);
        }
        
        /* 工具提示 */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 120px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            font-weight: normal;
            text-transform: none;
            letter-spacing: normal;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="container">
        <h1>3D风格迷宫生成器</h1>
        
        <div class="controls no-print">
            <div class="control-group">
                <label for="maze-type"><i class="fas fa-project-diagram"></i> 迷宫类型</label>
                <select id="maze-type">
                    <option value="recursive">递归分割迷宫</option>
                    <option value="prim">随机Prim迷宫</option>
                    <option value="kruskal">Kruskal迷宫</option>
                    <option value="backtracker">回溯法迷宫</option>
                    <option value="binary">二叉树迷宫</option>
                    <option value="sidewinder">Sidewinder迷宫</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="complexity"><i class="fas fa-layer-group"></i> 复杂度</label>
                <select id="complexity">
                    <option value="easy">简单 (10×10)</option>
                    <option value="medium" selected>中等 (20×20)</option>
                    <option value="hard">困难 (30×30)</option>
                    <option value="expert">专家 (50×50)</option>
                    <option value="custom">自定义</option>
                </select>
            </div>
            
            <div class="control-group" id="custom-size-group" style="display: none;">
                <label for="custom-size"><i class="fas fa-ruler-combined"></i> 自定义大小</label>
                <input type="number" id="custom-size" min="5" max="100" placeholder="输入迷宫尺寸 (5-100)">
            </div>
            
            <div class="control-group">
                <label><i class="fas fa-palette"></i> 颜色设置</label>
                <div class="color-inputs">
                    <input type="color" id="wall-color" value="#3a0ca3" title="墙壁颜色">
                    <input type="color" id="path-color" value="#4cc9f0" title="路径颜色">
                    <input type="color" id="player-color" value="#f72585" title="玩家颜色">
                </div>
            </div>
            
            <div class="control-group">
                <div class="button-group">
                    <button id="generate-btn" class="btn-primary btn-3d">
                        <i class="fas fa-sync-alt"></i> 生成迷宫
                    </button>
                    <button id="play-btn" class="btn-success btn-3d">
                        <i class="fas fa-gamepad"></i> 开始游戏
                    </button>
                </div>
                <div class="button-group">
                    <button id="print-btn" class="btn-secondary btn-3d">
                        <i class="fas fa-print"></i> 打印
                    </button>
                    <button id="solve-btn" class="btn-secondary btn-3d tooltip">
                        <i class="fas fa-route"></i> 显示解法
                        <span class="tooltiptext">显示迷宫的最短路径解法</span>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="game-controls no-print" id="game-controls">
            <div class="game-info" id="game-info">
                使用方向键或下方按钮移动 | 到达右下角出口获胜
            </div>
            <button id="up-btn" class="btn-primary btn-3d"><i class="fas fa-arrow-up"></i> 上</button>
            <button id="reset-btn" class="btn-warning btn-3d"><i class="fas fa-undo"></i> 重置</button>
            <button id="down-btn" class="btn-primary btn-3d"><i class="fas fa-arrow-down"></i> 下</button>
            <button id="left-btn" class="btn-primary btn-3d"><i class="fas fa-arrow-left"></i> 左</button>
            <button id="hint-btn" class="btn-success btn-3d"><i class="fas fa-lightbulb"></i> 提示</button>
            <button id="right-btn" class="btn-primary btn-3d"><i class="fas fa-arrow-right"></i> 右</button>
        </div>
        
        <div class="maze-container">
            <canvas id="maze-canvas"></canvas>
        </div>
        
        <div class="mobile-controls no-print" id="mobile-controls">
            <div></div>
            <button id="m-up-btn" class="btn-primary btn-3d"><i class="fas fa-arrow-up"></i></button>
            <div></div>
            <button id="m-left-btn" class="btn-primary btn-3d"><i class="fas fa-arrow-left"></i></button>
            <button id="m-hint-btn" class="btn-success btn-3d"><i class="fas fa-lightbulb"></i></button>
            <button id="m-right-btn" class="btn-primary btn-3d"><i class="fas fa-arrow-right"></i></button>
            <div></div>
            <button id="m-down-btn" class="btn-primary btn-3d"><i class="fas fa-arrow-down"></i></button>
            <div></div>
        </div>
        
        <div class="keyboard-hint no-print">
            <i class="fas fa-keyboard"></i> 使用键盘方向键移动玩家
        </div>
    </div>
    
    <div class="footer no-print">
        <p>迷宫生成器 &copy; 2023 | 使用HTML5 Canvas和JavaScript构建</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM元素
            const canvas = document.getElementById('maze-canvas');
            const ctx = canvas.getContext('2d');
            const generateBtn = document.getElementById('generate-btn');
            const playBtn = document.getElementById('play-btn');
            const printBtn = document.getElementById('print-btn');
            const solveBtn = document.getElementById('solve-btn');
            const resetBtn = document.getElementById('reset-btn');
            const mazeTypeSelect = document.getElementById('maze-type');
            const complexitySelect = document.getElementById('complexity');
            const customSizeGroup = document.getElementById('custom-size-group');
            const customSizeInput = document.getElementById('custom-size');
            const wallColorInput = document.getElementById('wall-color');
            const pathColorInput = document.getElementById('path-color');
            const playerColorInput = document.getElementById('player-color');
            const gameControls = document.getElementById('game-controls');
            const gameInfo = document.getElementById('game-info');
            const mobileControls = document.getElementById('mobile-controls');
            const keyboardHint = document.querySelector('.keyboard-hint');
            
            // 游戏控制按钮
            const upBtn = document.getElementById('up-btn');
            const downBtn = document.getElementById('down-btn');
            const leftBtn = document.getElementById('left-btn');
            const rightBtn = document.getElementById('right-btn');
            const hintBtn = document.getElementById('hint-btn');
            const mUpBtn = document.getElementById('m-up-btn');
            const mDownBtn = document.getElementById('m-down-btn');
            const mLeftBtn = document.getElementById('m-left-btn');
            const mRightBtn = document.getElementById('m-right-btn');
            const mHintBtn = document.getElementById('m-hint-btn');
            
            // 游戏状态
            let maze = [];
            let playerPos = { x: 0, y: 0 };
            let gameActive = false;
            let solutionPath = [];
            let showingSolution = false;
            let originalMaze = []; // 保存原始迷宫状态
            
            // 监听自定义大小选项
            complexitySelect.addEventListener('change', function() {
                customSizeGroup.style.display = this.value === 'custom' ? 'block' : 'none';
            });
            
            // 设置画布大小
            function setupCanvas() {
                const size = getMazeSize();
                const cellSize = Math.min(30, Math.max(10, 600 / size));
                canvas.width = size * cellSize;
                canvas.height = size * cellSize;
            }
            
            // 获取迷宫大小
            function getMazeSize() {
                if (complexitySelect.value === 'custom') {
                    const size = parseInt(customSizeInput.value) || 20;
                    return Math.min(100, Math.max(5, size));
                }
                
                switch(complexitySelect.value) {
                    case 'easy': return 10;
                    case 'medium': return 20;
                    case 'hard': return 30;
                    case 'expert': return 50;
                    default: return 20;
                }
            }
            
            // 生成迷宫
            function generateMaze() {
                const size = getMazeSize();
                const mazeType = mazeTypeSelect.value;
                const wallColor = wallColorInput.value;
                const pathColor = pathColorInput.value;
                
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 根据选择的算法生成迷宫
                switch(mazeType) {
                    case 'recursive':
                        maze = generateRecursiveDivisionMaze(size);
                        break;
                    case 'prim':
                        maze = generateRandomPrimMaze(size);
                        break;
                    case 'kruskal':
                        maze = generateKruskalMaze(size);
                        break;
                    case 'backtracker':
                        maze = generateBacktrackerMaze(size);
                        break;
                    case 'binary':
                        maze = generateBinaryTreeMaze(size);
                        break;
                    case 'sidewinder':
                        maze = generateSidewinderMaze(size);
                        break;
                }
                
                // 保存原始迷宫状态
                originalMaze = JSON.parse(JSON.stringify(maze));
                
                // 重置玩家位置
                playerPos = { x: 0, y: 0 };
                gameActive = false;
                showingSolution = false;
                solutionPath = [];
                
                // 绘制迷宫
                drawMaze();
                
                // 隐藏游戏控制
                gameControls.style.display = 'none';
                mobileControls.style.display = 'none';
                keyboardHint.style.display = 'none';
            }
            
            // 开始游戏
            function startGame() {
                gameActive = true;
                showingSolution = false;
                playerPos = { x: 0, y: 0 };
                
                // 显示游戏控制
                gameControls.style.display = 'grid';
                mobileControls.style.display = 'grid';
                keyboardHint.style.display = 'block';
                
                // 绘制迷宫和玩家
                drawMaze();
                drawPlayer();
            }
            
            // 重置游戏
            function resetGame() {
                if (originalMaze.length === 0) return;
                
                // 恢复原始迷宫状态
                maze = JSON.parse(JSON.stringify(originalMaze));
                
                // 重置游戏状态
                gameActive = true;
                showingSolution = false;
                playerPos = { x: 0, y: 0 };
                solutionPath = [];
                
                // 更新游戏信息
                gameInfo.textContent = "使用方向键或下方按钮移动 | 到达右下角出口获胜";
                
                // 重绘
                drawMaze();
                drawPlayer();
            }
            
            // 递归分割迷宫算法
            function generateRecursiveDivisionMaze(size) {
                const maze = Array(size).fill().map(() => 
                    Array(size).fill().map(() => ({
                        top: true, right: true, bottom: true, left: true,
                        visited: false
                    }))
                );
                
                function divide(x, y, width, height, orientation) {
                    if (width < 2 || height < 2) return;
                    
                    const horizontal = orientation === 'horizontal';
                    const wx = x + (horizontal ? 0 : Math.floor(Math.random() * (width - 1)));
                    const wy = y + (horizontal ? Math.floor(Math.random() * (height - 1)) : 0);
                    const px = wx + (horizontal ? Math.floor(Math.random() * width) : 0);
                    const py = wy + (horizontal ? 0 : Math.floor(Math.random() * height));
                    
                    const dx = horizontal ? 1 : 0;
                    const dy = horizontal ? 0 : 1;
                    
                    const length = horizontal ? width : height;
                    
                    for (let i = 0; i < length; i++) {
                        if (wx + dx * i !== px || wy + dy * i !== py) {
                            if (horizontal) {
                                maze[wy + dy * i][wx + dx * i].bottom = false;
                                maze[wy + dy * i + 1][wx + dx * i].top = false;
                            } else {
                                maze[wy + dy * i][wx + dx * i].right = false;
                                maze[wy + dy * i][wx + dx * i + 1].left = false;
                            }
                        }
                    }
                
                    const [nx, ny, nw, nh] = horizontal ? 
                        [x, y, width, wy - y + 1] : [x, y, wx - x + 1, height];
                    divide(nx, ny, nw, nh, chooseOrientation(nw, nh));
                
                    const [nx2, ny2, nw2, nh2] = horizontal ? 
                        [x, wy + 1, width, y + height - wy - 1] : [wx + 1, y, x + width - wx - 1, height];
                    divide(nx2, ny2, nw2, nh2, chooseOrientation(nw2, nh2));
                }
                
                function chooseOrientation(width, height) {
                    if (width < height) return 'horizontal';
                    if (height < width) return 'vertical';
                    return Math.random() < 0.5 ? 'horizontal' : 'vertical';
                }
                
                // 开始递归分割
                divide(0, 0, size, size, chooseOrientation(size, size));
                
                // 设置入口和出口
                maze[0][0].left = false;
                maze[size-1][size-1].right = false;
                
                return maze;
            }
            
            // 随机Prim算法
            function generateRandomPrimMaze(size) {
                const maze = Array(size).fill().map(() => 
                    Array(size).fill().map(() => ({
                        top: true, right: true, bottom: true, left: true,
                        visited: false
                    }))
                );
                
                // 从随机位置开始
                const startX = Math.floor(Math.random() * size);
                const startY = Math.floor(Math.random() * size);
                maze[startY][startX].visited = true;
                
                const walls = [];
                
                // 添加初始单元格的墙壁
                function addWalls(x, y) {
                    if (x > 0 && !maze[y][x-1].visited) walls.push({x, y, dir: 'left'});
                    if (x < size-1 && !maze[y][x+1].visited) walls.push({x, y, dir: 'right'});
                    if (y > 0 && !maze[y-1][x].visited) walls.push({x, y, dir: 'top'});
                    if (y < size-1 && !maze[y+1][x].visited) walls.push({x, y, dir: 'bottom'});
                }
                
                addWalls(startX, startY);
                
                while (walls.length > 0) {
                    // 随机选择一堵墙
                    const randomIndex = Math.floor(Math.random() * walls.length);
                    const wall = walls[randomIndex];
                    walls.splice(randomIndex, 1);
                    
                    const {x, y, dir} = wall;
                    let nx = x, ny = y;
                    
                    switch(dir) {
                        case 'left': nx--; break;
                        case 'right': nx++; break;
                        case 'top': ny--; break;
                        case 'bottom': ny++; break;
                    }
                    
                    if (nx >= 0 && nx < size && ny >= 0 && ny < size && !maze[ny][nx].visited) {
                        // 打通墙壁
                        switch(dir) {
                            case 'left':
                                maze[y][x].left = false;
                                maze[ny][nx].right = false;
                                break;
                            case 'right':
                                maze[y][x].right = false;
                                maze[ny][nx].left = false;
                                break;
                            case 'top':
                                maze[y][x].top = false;
                                maze[ny][nx].bottom = false;
                                break;
                            case 'bottom':
                                maze[y][x].bottom = false;
                                maze[ny][nx].top = false;
                                break;
                        }
                        
                        maze[ny][nx].visited = true;
                        addWalls(nx, ny);
                    }
                }
                
                // 设置入口和出口
                maze[0][0].left = false;
                maze[size-1][size-1].right = false;
                
                return maze;
            }
            
            // Kruskal算法
            function generateKruskalMaze(size) {
                const maze = Array(size).fill().map(() => 
                    Array(size).fill().map(() => ({
                        top: true, right: true, bottom: true, left: true,
                        set: 0
                    }))
                );
                
                // 初始化每个单元格属于不同的集合
                let setCounter = 1;
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        maze[y][x].set = setCounter++;
                    }
                }
                
                // 创建所有可能的墙壁
                const walls = [];
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        if (x < size - 1) walls.push({x, y, dir: 'right'});
                        if (y < size - 1) walls.push({x, y, dir: 'bottom'});
                    }
                }
                
                // 随机排序墙壁
                walls.sort(() => Math.random() - 0.5);
                
                // 查找根集合
                function findSet(x, y) {
                    while (maze[y][x].set !== x * size + y + 1) {
                        const pos = maze[y][x].set - 1;
                        x = pos % size;
                        y = Math.floor(pos / size);
                    }
                    return maze[y][x].set;
                }
                
                // 处理每堵墙
                for (const wall of walls) {
                    const {x, y, dir} = wall;
                    let nx = x, ny = y;
                    
                    if (dir === 'right') nx++;
                    else if (dir === 'bottom') ny++;
                    
                    const set1 = findSet(x, y);
                    const set2 = findSet(nx, ny);
                    
                    if (set1 !== set2) {
                        // 合并集合
                        for (let iy = 0; iy < size; iy++) {
                            for (let ix = 0; ix < size; ix++) {
                                if (maze[iy][ix].set === set2) {
                                    maze[iy][ix].set = set1;
                                }
                            }
                        }
                        
                        // 打通墙壁
                        if (dir === 'right') {
                            maze[y][x].right = false;
                            maze[ny][nx].left = false;
                        } else {
                            maze[y][x].bottom = false;
                            maze[ny][nx].top = false;
                        }
                    }
                }
                
                // 设置入口和出口
                maze[0][0].left = false;
                maze[size-1][size-1].right = false;
                
                return maze;
            }
            
            // 回溯法
            function generateBacktrackerMaze(size) {
                const maze = Array(size).fill().map(() => 
                    Array(size).fill().map(() => ({
                        top: true, right: true, bottom: true, left: true,
                        visited: false
                    }))
                );
                
                const stack = [];
                
                // 从随机位置开始
                const startX = Math.floor(Math.random() * size);
                const startY = Math.floor(Math.random() * size);
                maze[startY][startX].visited = true;
                stack.push({x: startX, y: startY});
                
                while (stack.length > 0) {
                    const {x, y} = stack[stack.length - 1];
                    
                    // 获取未访问的邻居
                    const neighbors = [];
                    
                    if (x > 0 && !maze[y][x-1].visited) neighbors.push({nx: x-1, ny: y, dir: 'left'});
                    if (x < size-1 && !maze[y][x+1].visited) neighbors.push({nx: x+1, ny: y, dir: 'right'});
                    if (y > 0 && !maze[y-1][x].visited) neighbors.push({nx: x, ny: y-1, dir: 'top'});
                    if (y < size-1 && !maze[y+1][x].visited) neighbors.push({nx: x, ny: y+1, dir: 'bottom'});
                    
                    if (neighbors.length === 0) {
                        stack.pop();
                        continue;
                    }
                    
                    // 随机选择一个邻居
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    const {nx, ny, dir} = next;
                    
                    // 打通墙壁
                    switch(dir) {
                        case 'left':
                            maze[y][x].left = false;
                            maze[ny][nx].right = false;
                            break;
                        case 'right':
                            maze[y][x].right = false;
                            maze[ny][nx].left = false;
                            break;
                        case 'top':
                            maze[y][x].top = false;
                            maze[ny][nx].bottom = false;
                            break;
                        case 'bottom':
                            maze[y][x].bottom = false;
                            maze[ny][nx].top = false;
                            break;
                    }
                    
                    maze[ny][nx].visited = true;
                    stack.push({x: nx, y: ny});
                }
                
                // 设置入口和出口
                maze[0][0].left = false;
                maze[size-1][size-1].right = false;
                
                return maze;
            }
            
            // 二叉树迷宫
            function generateBinaryTreeMaze(size) {
                const maze = Array(size).fill().map(() => 
                    Array(size).fill().map(() => ({
                        top: true, right: true, bottom: true, left: true
                    }))
                );
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const options = [];
                        if (x > 0) options.push('left');
                        if (y > 0) options.push('top');
                        
                        if (options.length > 0) {
                            const dir = options[Math.floor(Math.random() * options.length)];
                            
                            if (dir === 'left') {
                                maze[y][x].left = false;
                                maze[y][x-1].right = false;
                            } else if (dir === 'top') {
                                maze[y][x].top = false;
                                maze[y-1][x].bottom = false;
                            }
                        }
                    }
                }
                
                // 设置入口和出口
                maze[0][0].left = false;
                maze[size-1][size-1].right = false;
                
                return maze;
            }
            
            // Sidewinder迷宫
            function generateSidewinderMaze(size) {
                const maze = Array(size).fill().map(() => 
                    Array(size).fill().map(() => ({
                        top: true, right: true, bottom: true, left: true
                    }))
                );
                
                for (let y = 0; y < size; y++) {
                    let run = [];
                    
                    for (let x = 0; x < size; x++) {
                        run.push({x, y});
                        
                        const atEasternBoundary = x === size - 1;
                        const atNorthernBoundary = y === 0;
                        
                        const shouldCloseOut = atEasternBoundary || 
                            (!atNorthernBoundary && Math.random() < 0.5);
                        
                        if (shouldCloseOut) {
                            const member = run[Math.floor(Math.random() * run.length)];
                            
                            if (member.y > 0) {
                                maze[member.y][member.x].top = false;
                                maze[member.y-1][member.x].bottom = false;
                            }
                            
                            run = [];
                        } else {
                            maze[y][x].right = false;
                            maze[y][x+1].left = false;
                        }
                    }
                }
                
                // 设置入口和出口
                maze[0][0].left = false;
                maze[size-1][size-1].right = false;
                
                return maze;
            }
            
            // 绘制迷宫
            function drawMaze() {
                const size = maze.length;
                const cellSize = canvas.width / size;
                const wallColor = wallColorInput.value;
                const pathColor = pathColorInput.value;
                
                // 填充背景
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制墙壁
                ctx.strokeStyle = wallColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const cell = maze[y][x];
                        const xPos = x * cellSize;
                        const yPos = y * cellSize;
                        
                        if (cell.top) {
                            ctx.moveTo(xPos, yPos);
                            ctx.lineTo(xPos + cellSize, yPos);
                        }
                        
                        if (cell.right) {
                            ctx.moveTo(xPos + cellSize, yPos);
                            ctx.lineTo(xPos + cellSize, yPos + cellSize);
                        }
                        
                        if (cell.bottom) {
                            ctx.moveTo(xPos, yPos + cellSize);
                            ctx.lineTo(xPos + cellSize, yPos + cellSize);
                        }
                        
                        if (cell.left) {
                            ctx.moveTo(xPos, yPos);
                            ctx.lineTo(xPos, yPos + cellSize);
                        }
                    }
                }
                
                ctx.stroke();
                
                // 绘制入口和出口
                const entranceSize = cellSize * 0.6;
                const exitSize = cellSize * 0.6;
                
                ctx.fillStyle = pathColor;
                ctx.fillRect(0, cellSize * 0.2, entranceSize / 2, entranceSize);
                ctx.fillStyle = '#38b000'; // 出口使用绿色
                ctx.fillRect(canvas.width - exitSize / 2, canvas.height - cellSize * 0.2 - exitSize, 
                             exitSize / 2, exitSize);
                
                // 如果显示解法，绘制解法路径
                if (showingSolution && solutionPath.length > 0) {
                    ctx.strokeStyle = 'rgba(76, 201, 240, 0.5)';
                    ctx.lineWidth = cellSize * 0.4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    
                    // 从入口开始
                    ctx.moveTo(cellSize * 0.3, cellSize * 0.5);
                    
                    // 绘制路径
                    solutionPath.forEach((point, index) => {
                        if (index > 0) {
                            const prev = solutionPath[index - 1];
                            const midX = (prev.x + point.x) / 2 * cellSize + cellSize / 2;
                            const midY = (prev.y + point.y) / 2 * cellSize + cellSize / 2;
                            ctx.lineTo(midX, midY);
                        }
                        ctx.lineTo(point.x * cellSize + cellSize / 2, point.y * cellSize + cellSize / 2);
                    });
                    
                    ctx.stroke();
                }
            }
            
            // 绘制玩家
            function drawPlayer() {
                if (!gameActive) return;
                
                const size = maze.length;
                const cellSize = canvas.width / size;
                const playerColor = playerColorInput.value;
                
                // 清除玩家所在单元格
                const {x, y} = playerPos;
                ctx.clearRect(x * cellSize + 1, y * cellSize + 1, cellSize - 2, cellSize - 2);
                
                // 绘制玩家
                ctx.fillStyle = playerColor;
                ctx.beginPath();
                ctx.arc(
                    x * cellSize + cellSize / 2,
                    y * cellSize + cellSize / 2,
                    cellSize * 0.35,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // 添加小亮点使玩家看起来更立体
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(
                    x * cellSize + cellSize / 2 - cellSize * 0.1,
                    y * cellSize + cellSize / 2 - cellSize * 0.1,
                    cellSize * 0.1,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // 检查是否到达出口
                if (x === size - 1 && y === size - 1) {
                    gameActive = false;
                    gameInfo.textContent = "恭喜！你成功走出了迷宫！点击'重置'可以重新挑战";
                    
                    // 显示庆祝动画
                    const confettiCount = 100;
                    const confetti = [];
                    
                    for (let i = 0; i < confettiCount; i++) {
                        confetti.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height - canvas.height,
                            r: Math.random() * 4 + 2,
                            d: Math.random() * confettiCount,
                            color: `hsl(${Math.random() * 360}, 100%, 50%)`
                        });
                    }
                    
                    function drawConfetti() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        drawMaze();
                        drawPlayer();
                        
                        for (let i = 0; i < confetti.length; i++) {
                            const p = confetti[i];
                            ctx.fillStyle = p.color;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                            ctx.fill();
                            
                            p.y += (Math.sin(p.d) + 1 + p.r / 2) / 2;
                            p.x += Math.sin(p.d) * 0.5;
                            
                            if (p.y > canvas.height) {
                                p.y = -p.r;
                                p.x = Math.random() * canvas.width;
                            }
                        }
                        
                        if (gameActive) return;
                        requestAnimationFrame(drawConfetti);
                    }
                    
                    drawConfetti();
                }
            }
            
            // 移动玩家
            function movePlayer(dx, dy) {
                if (!gameActive) return;
                
                const {x, y} = playerPos;
                const newX = x + dx;
                const newY = y + dy;
                const size = maze.length;
                
                // 检查边界
                if (newX < 0 || newX >= size || newY < 0 || newY >= size) return;
                
                // 检查墙壁
                if (dx === -1 && maze[y][x].left) return;    // 向左移动检查左墙
                if (dx === 1 && maze[y][x].right) return;    // 向右移动检查右墙
                if (dy === -1 && maze[y][x].top) return;     // 向上移动检查上墙
                if (dy === 1 && maze[y][x].bottom) return;  // 向下移动检查下墙
                
                // 更新位置
                playerPos.x = newX;
                playerPos.y = newY;
                
                // 重绘
                drawMaze();
                drawPlayer();
            }
            
            // 解决迷宫 - 使用广度优先搜索
            function solveMaze() {
                const size = maze.length;
                const visited = Array(size).fill().map(() => Array(size).fill(false));
                const queue = [];
                const parent = Array(size).fill().map(() => Array(size).fill(null));
                
                // 从入口开始
                queue.push({x: 0, y: 0});
                visited[0][0] = true;
                
                // 方向: 上, 右, 下, 左
                const directions = [
                    {dx: 0, dy: -1, wall: 'top'}, 
                    {dx: 1, dy: 0, wall: 'right'}, 
                    {dx: 0, dy: 1, wall: 'bottom'}, 
                    {dx: -1, dy: 0, wall: 'left'}
                ];
                
                while (queue.length > 0) {
                    const {x, y} = queue.shift();
                    
                    // 如果到达出口，回溯路径
                    if (x === size - 1 && y === size - 1) {
                        const path = [];
                        let current = {x: size - 1, y: size - 1};
                        
                        while (current.x !== 0 || current.y !== 0) {
                            path.unshift(current);
                            current = parent[current.y][current.x];
                        }
                        path.unshift({x: 0, y: 0});
                        
                        solutionPath = path;
                        showingSolution = true;
                        drawMaze();
                        if (gameActive) drawPlayer();
                        return;
                    }
                    
                    // 检查所有方向
                    for (const dir of directions) {
                        const nx = x + dir.dx;
                        const ny = y + dir.dy;
                        
                        // 检查边界
                        if (nx < 0 || nx >= size || ny < 0 || ny >= size) continue;
                        
                        // 检查墙壁
                        if (maze[y][x][dir.wall]) continue;
                        
                        // 检查是否已访问
                        if (!visited[ny][nx]) {
                            visited[ny][nx] = true;
                            parent[ny][nx] = {x, y};
                            queue.push({x: nx, y: ny});
                        }
                    }
                }
                
                // 如果没有找到路径
                solutionPath = [];
                showingSolution = true;
                drawMaze();
                if (gameActive) drawPlayer();
                alert("无法找到解决方案！");
            }
            
            // 显示下一步提示
            function showHint() {
                if (!gameActive) return;
                
                // 如果还没有解法，先计算解法
                if (solutionPath.length === 0) {
                    solveMaze();
                    showingSolution = false; // 不显示完整解法，只显示提示
                }
                
                // 找到玩家当前位置在解法路径中的位置
                let currentIndex = -1;
                for (let i = 0; i < solutionPath.length; i++) {
                    const {x, y} = solutionPath[i];
                    if (x === playerPos.x && y === playerPos.y) {
                        currentIndex = i;
                        break;
                    }
                }
                
                if (currentIndex === -1 || currentIndex >= solutionPath.length - 1) {
                    alert("你已经到达终点或不在解法路径上！");
                    return;
                }
                
                // 获取下一步
                const nextStep = solutionPath[currentIndex + 1];
                const dx = nextStep.x - playerPos.x;
                const dy = nextStep.y - playerPos.y;
                
                let direction;
                if (dx === 1) direction = "右";
                else if (dx === -1) direction = "左";
                else if (dy === 1) direction = "下";
                else if (dy === -1) direction = "上";
                
                gameInfo.textContent = `提示: 下一步向 ${direction} 移动`;
                
                // 高亮显示下一步
                const size = maze.length;
                const cellSize = canvas.width / size;
                const {x, y} = nextStep;
                
                ctx.fillStyle = 'rgba(72, 149, 239, 0.3)';
                ctx.fillRect(
                    x * cellSize + 2,
                    y * cellSize + 2,
                    cellSize - 4,
                    cellSize - 4
                );
                
                drawPlayer();
            }
            
            // 事件监听
            generateBtn.addEventListener('click', generateMaze);
            playBtn.addEventListener('click', startGame);
            printBtn.addEventListener('click', function() {
                window.print();
            });
            solveBtn.addEventListener('click', function() {
                if (maze.length === 0) return;
                solveMaze();
            });
            resetBtn.addEventListener('click', resetGame);
            hintBtn.addEventListener('click', showHint);
            mHintBtn.addEventListener('click', showHint);
            
            // 方向控制
            upBtn.addEventListener('click', () => movePlayer(0, -1));
            downBtn.addEventListener('click', () => movePlayer(0, 1));
            leftBtn.addEventListener('click', () => movePlayer(-1, 0));
            rightBtn.addEventListener('click', () => movePlayer(1, 0));
            
            mUpBtn.addEventListener('click', () => movePlayer(0, -1));
            mDownBtn.addEventListener('click', () => movePlayer(0, 1));
            mLeftBtn.addEventListener('click', () => movePlayer(-1, 0));
            mRightBtn.addEventListener('click', () => movePlayer(1, 0));
            
            // 键盘控制
            document.addEventListener('keydown', function(e) {
                if (!gameActive) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        movePlayer(0, -1);
                        break;
                    case 'ArrowRight':
                        movePlayer(1, 0);
                        break;
                    case 'ArrowDown':
                        movePlayer(0, 1);
                        break;
                    case 'ArrowLeft':
                        movePlayer(-1, 0);
                        break;
                }
            });
            
            // 窗口大小改变时调整画布
            window.addEventListener('resize', function() {
                setupCanvas();
                if (maze.length > 0) {
                    drawMaze();
                    if (gameActive) drawPlayer();
                }
            });
            
            // 首次加载时生成一个默认迷宫
            setupCanvas();
            generateMaze();
        });
    </script>
</body>
</html>
