<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>液体物理模拟</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        
        #canvas {
            display: block;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            margin: 10px auto;
            width: 95vw;
            height: 65vh;
            max-width: 1400px;
            max-height: 700px;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            padding-bottom: 5px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 600;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .header p {
            font-size: 1rem;
            opacity: 0.8;
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-top: auto;
            margin-bottom: 5px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            max-width: 100%;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 200px;
        }
        
        .control-group label {
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .value-display {
            min-width: 40px;
            text-align: center;
            font-weight: 500;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-family: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-size: 0.9rem;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #2196F3 0%, #0b7dda 100%);
            color: white;
        }
        
        .btn-accent {
            background: linear-gradient(135deg, #FF9800 0%, #e68900 100%);
            color: white;
        }
        
        .btn-rainbow {
            background: linear-gradient(135deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            background-size: 300% 300%;
            animation: rainbow 3s ease infinite;
            color: white;
        }
        
        .btn-explosion {
            background: linear-gradient(135deg, #ff4500 0%, #ff6347 100%);
            color: white;
        }
        
        .btn-vortex {
            background: linear-gradient(135deg, #4b0082 0%, #8a2be2 100%);
            color: white;
        }
        
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        
        .btn:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            border-radius: 10px;
            padding: 15px;
            font-size: 0.8rem;
            max-width: 200px;
        }
        
        .info-panel h3 {
            margin-bottom: 10px;
            font-size: 1rem;
        }
        
        .info-panel p {
            margin-bottom: 5px;
            opacity: 0.8;
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                padding: 15px;
            }
            
            .control-group {
                min-width: 150px;
            }
            
            .info-panel {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>液体物理模拟</h1>
            <p>点击或拖动鼠标添加液体粒子，体验逼真的物理效果</p>
        </div>
        
        <canvas id="canvas"></canvas>
        
        <div class="controls">
            <div class="button-group">
                <button id="resetBtn" class="btn btn-primary">重置模拟</button>
                <button id="pauseBtn" class="btn btn-secondary">暂停/继续</button>
                <button id="cycleBtn" class="btn btn-accent">循环模式</button>
            </div>
            
            <div class="button-group">
                <button id="rainbowBtn" class="btn btn-rainbow">彩虹模式</button>
                <button id="explosionBtn" class="btn btn-explosion">爆炸效果</button>
                <button id="vortexBtn" class="btn btn-vortex">漩涡效果</button>
            </div>
            
            <div class="control-group">
                <label>重力</label>
                <div class="slider-container">
                    <input type="range" id="gravitySlider" class="slider" min="0" max="2" step="0.1" value="0.5">
                    <span id="gravityValue" class="value-display">0.5</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>粘性</label>
                <div class="slider-container">
                    <input type="range" id="viscositySlider" class="slider" min="0" max="1" step="0.05" value="0.2">
                    <span id="viscosityValue" class="value-display">0.2</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>粒子数量</label>
                <div class="slider-container">
                    <input type="range" id="particleCountSlider" class="slider" min="50" max="500" step="50" value="200">
                    <span id="particleCountValue" class="value-display">200</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>表面张力</label>
                <div class="slider-container">
                    <input type="range" id="surfaceTensionSlider" class="slider" min="0" max="1" step="0.05" value="0.3">
                    <span id="surfaceTensionValue" class="value-display">0.3</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>粒子大小</label>
                <div class="slider-container">
                    <input type="range" id="particleSizeSlider" class="slider" min="2" max="15" step="1" value="5">
                    <span id="particleSizeValue" class="value-display">5</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>风力</label>
                <div class="slider-container">
                    <input type="range" id="windSlider" class="slider" min="-1" max="1" step="0.1" value="0">
                    <span id="windValue" class="value-display">0</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="info-panel">
        <h3>操作提示</h3>
        <p>• 点击添加粒子</p>
        <p>• 拖动创建液体流</p>
        <p>• 调整参数改变效果</p>
        <p>• 开启循环模式体验连续流动</p>
        <p>• 彩虹模式：粒子颜色不断变化</p>
        <p>• 爆炸效果：创建向外扩散的粒子</p>
        <p>• 漩涡效果：点击画布设置漩涡中心</p>
        <p>• 调整粒子大小和风力</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // 设置画布大小
        function resizeCanvas() {
            // 设置画布实际尺寸
            canvas.width = Math.min(window.innerWidth * 0.95, 1400);
            canvas.height = Math.min(window.innerHeight * 0.65, 700);
            
            // 更新漩涡中心位置
            vortexCenter.x = canvas.width / 2;
            vortexCenter.y = canvas.height / 2;
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', () => {
            resizeCanvas();
            initParticles();
            animate();
        });
        
        // 窗口大小改变时重新设置画布大小
        window.addEventListener('resize', resizeCanvas);
        
        // 控制变量
        let isPaused = false;
        let gravity = 0.5;
        let viscosity = 0.2;
        let particleCount = 200;
        let surfaceTension = 0.3;
        let cycleMode = false;
        let cycleParticles = [];
        // 用户创建的粒子不计入粒子数量限制
        let userCreatedParticles = [];
        const MAX_USER_PARTICLES = 3000; // 大幅增加用户可创建的最大粒子数，确保可以随时创建液体流
        
        // 新增控制变量
        let particleSize = 5;
        let windForce = 0;
        let rainbowMode = false;
        let explosionMode = false;
        let vortexMode = false;
        let vortexCenter = { x: canvas.width / 2, y: canvas.height / 2 };
        let vortexStrength = 0;
        
        // 粒子类
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.radius = particleSize;
                this.density = 0;
                this.pressure = 0;
                this.hue = Math.random() * 360; // 用于彩虹模式
                
                // 根据模式设置颜色
                this.updateColor();
            }
            
            updateColor() {
                if (rainbowMode) {
                    // 彩虹模式：使用HSL颜色空间，随时间变化
                    this.hue = (this.hue + 1) % 360;
                    this.color = `hsla(${this.hue}, 100%, 50%, 0.8)`;
                } else if (explosionMode) {
                    // 爆炸模式：使用红橙色调
                    const redShade = Math.floor(Math.random() * 55) + 200;
                    const greenShade = Math.floor(Math.random() * 100);
                    this.color = `rgba(${redShade}, ${greenShade}, 0, 0.8)`;
                } else if (vortexMode) {
                    // 漩涡模式：使用紫色调
                    const purpleShade = Math.floor(Math.random() * 100) + 100;
                    this.color = `rgba(${purpleShade}, 0, ${purpleShade + 55}, 0.8)`;
                } else {
                    // 默认模式：随机蓝色调
                    const blueShade = Math.floor(Math.random() * 100) + 150;
                    this.color = `rgba(64, 164, ${blueShade}, 0.8)`;
                }
            }
            
            update() {
                if (isPaused) return;
                
                // 应用重力
                this.vy += gravity;
                
                // 应用风力
                this.vx += windForce;
                
                // 应用漩涡效果
                if (vortexMode && vortexStrength > 0) {
                    const dx = vortexCenter.x - this.x;
                    const dy = vortexCenter.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 10) { // 避免除以零和过度接近中心
                        // 计算切向力（垂直于径向）
                        const tangentX = -dy / distance;
                        const tangentY = dx / distance;
                        
                        // 应用漩涡力
                        const force = vortexStrength / Math.max(distance * 0.01, 1);
                        this.vx += tangentX * force;
                        this.vy += tangentY * force;
                        
                        // 轻微的向心力
                        this.vx += dx / distance * force * 0.1;
                        this.vy += dy / distance * force * 0.1;
                    }
                }
                
                // 应用粘性（速度衰减）
                this.vx *= (1 - viscosity * 0.1);
                this.vy *= (1 - viscosity * 0.1);
                
                // 更新位置
                this.x += this.vx;
                this.y += this.vy;
                
                // 边界碰撞检测
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= -0.5; // 反弹并损失能量
                } else if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx *= -0.5;
                }
                
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= -0.5;
                } else if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.vy *= -0.5;
                    
                    // 循环模式：从底部移除的粒子重新从顶部出现
                    if (cycleMode) {
                        this.y = this.radius;
                        this.x = Math.random() * canvas.width;
                        this.vy = 0;
                        this.vx = (Math.random() - 0.5) * 2;
                    }
                }
                
                // 更新颜色（用于彩虹模式）
                if (rainbowMode) {
                    this.updateColor();
                }
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // 添加光晕效果
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 1.5);
                gradient.addColorStop(0, this.color.replace('0.8', '0.3'));
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.closePath();
            }
        }
        
        // 初始化粒子
        let particles = [];
        function initParticles() {
            particles = [];
            for (let i = 0; i < particleCount; i++) {
                // 在画布上半部分随机生成粒子
                const x = Math.random() * canvas.width;
                const y = Math.random() * (canvas.height / 2);
                particles.push(new Particle(x, y));
            }
        }
        
        // 粒子间相互作用
        function applyParticleInteractions(particlesArray = particles) {
            // 计算密度和压力
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].density = 0;
                particlesArray[i].pressure = 0;
                
                for (let j = 0; j < particlesArray.length; j++) {
                    if (i === j) continue;
                    
                    const p1 = particlesArray[i];
                    const p2 = particlesArray[j];
                    
                    // 计算粒子间距离
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 计算密度（简化的SPH方法）
                    if (distance < 50) {
                        p1.density += 1 - (distance / 50);
                    }
                }
                
                // 计算压力
                particlesArray[i].pressure = particlesArray[i].density * surfaceTension;
            }
            
            // 应用压力和粘性力
            for (let i = 0; i < particlesArray.length; i++) {
                for (let j = i + 1; j < particlesArray.length; j++) {
                    const p1 = particlesArray[i];
                    const p2 = particlesArray[j];
                    
                    // 计算粒子间距离
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 如果粒子太近，应用排斥力
                    const minDistance = p1.radius + p2.radius;
                    if (distance < minDistance) {
                        // 计算排斥力
                        const angle = Math.atan2(dy, dx);
                        const targetDistance = minDistance;
                        const force = (targetDistance - distance) * 0.05;
                        
                        const ax = Math.cos(angle) * force;
                        const ay = Math.sin(angle) * force;
                        
                        // 应用力到两个粒子
                        p1.vx -= ax;
                        p1.vy -= ay;
                        p2.vx += ax;
                        p2.vy += ay;
                    }
                    
                    // 应用表面张力（粒子间吸引力）
                    if (distance > minDistance && distance < 30) {
                        const angle = Math.atan2(dy, dx);
                        const tensionForce = surfaceTension * 0.01;
                        
                        const ax = Math.cos(angle) * tensionForce;
                        const ay = Math.sin(angle) * tensionForce;
                        
                        // 应用力到两个粒子
                        p1.vx += ax;
                        p1.vy += ay;
                        p2.vx -= ax;
                        p2.vy -= ay;
                    }
                    
                    // 应用压力
                    if (distance < 30 && distance > minDistance) {
                        const pressureForce = (p1.pressure + p2.pressure) * 0.01;
                        const angle = Math.atan2(dy, dx);
                        
                        const ax = Math.cos(angle) * pressureForce;
                        const ay = Math.sin(angle) * pressureForce;
                        
                        // 应用力到两个粒子
                        p1.vx -= ax;
                        p1.vy -= ay;
                        p2.vx += ax;
                        p2.vy += ay;
                    }
                }
            }
        }
        
        // 鼠标交互
        let mouseX = 0;
        let mouseY = 0;
        let isMouseDown = false;
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            
            if (isMouseDown) {
                createParticlesAtPosition(mouseX, mouseY);
            }
        });
        
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            createParticlesAtPosition(mouseX, mouseY);
        });
        
        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // 在指定位置创建粒子
        function createParticlesAtPosition(x, y) {
            // 计算可添加的粒子数量，确保可以随时创建液体流
            const availableSlots = MAX_USER_PARTICLES - userCreatedParticles.length;
            const particlesToAdd = Math.min(5, Math.max(1, availableSlots)); // 至少添加1个粒子，最多5个
            
            // 如果粒子数量接近上限，先移除一些最早的粒子
            if (availableSlots < 5 && userCreatedParticles.length > 0) {
                const particlesToRemove = Math.min(10, userCreatedParticles.length);
                userCreatedParticles.splice(0, particlesToRemove);
            }
            
            // 添加新粒子
            for (let i = 0; i < particlesToAdd; i++) {
                const offsetX = (Math.random() - 0.5) * 20;
                const offsetY = (Math.random() - 0.5) * 20;
                userCreatedParticles.push(new Particle(x + offsetX, y + offsetY));
            }
        }
        
        // 触摸事件支持
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            createParticlesAtPosition(x, y);
        });

        canvas.addEventListener('touchend', () => {
            isMouseDown = false;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                createParticlesAtPosition(x, y);
            }
        });
        
        // 动画循环
        function animate() {
            // 清空画布，使用半透明背景创建拖尾效果
            ctx.fillStyle = 'rgba(30, 60, 114, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 合并所有粒子进行物理模拟
            const allParticles = [...particles, ...userCreatedParticles];
            
            // 应用粒子间相互作用
            applyParticleInteractions(allParticles);
            
            // 更新和绘制所有粒子
            for (const particle of allParticles) {
                particle.update();
                particle.draw();
            }
            
            // 移除超出画布边界过多的用户创建粒子（保留更多粒子，允许更长时间的液体流）
            // 只有当粒子超出底部边界很多时才移除，这样可以确保液体流可以持续创建
            userCreatedParticles = userCreatedParticles.filter(particle => {
                return particle.y - particle.radius < canvas.height + 500; // 允许粒子超出底部500像素
            });
            
            // 如果用户创建的粒子过多，移除最早的粒子
            // 增加最大粒子数，确保可以持续创建液体流
            while (userCreatedParticles.length > MAX_USER_PARTICLES) {
                userCreatedParticles.shift();
            }
            
            // 在循环模式下，在顶部添加新粒子，但不超过设定的粒子数量
            if (cycleMode && particles.length < particleCount) {
                if (Math.random() < 0.3) {
                    const x = Math.random() * canvas.width;
                    particles.push(new Particle(x, 5));
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // 控制面板事件
        document.getElementById('resetBtn').addEventListener('click', () => {
            // 重置用户创建的粒子
            userCreatedParticles = [];
            
            // 确保粒子数量不超过设定值
            while (particles.length > particleCount) {
                particles.pop();
            }
            // 如果粒子数量少于设定值，添加新粒子
            while (particles.length < particleCount) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * (canvas.height / 2);
                particles.push(new Particle(x, y));
            }
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            isPaused = !isPaused;
        });
        
        document.getElementById('cycleBtn').addEventListener('click', () => {
            cycleMode = !cycleMode;
            const btn = document.getElementById('cycleBtn');
            if (cycleMode) {
                btn.textContent = '关闭循环';
                btn.style.background = 'linear-gradient(135deg, #f44336 0%, #d32f2f 100%)';
            } else {
                btn.textContent = '循环模式';
                btn.style.background = 'linear-gradient(135deg, #FF9800 0%, #e68900 100%)';
            }
        });
        
        document.getElementById('gravitySlider').addEventListener('input', (e) => {
            gravity = parseFloat(e.target.value);
            document.getElementById('gravityValue').textContent = gravity;
        });
        
        document.getElementById('viscositySlider').addEventListener('input', (e) => {
            viscosity = parseFloat(e.target.value);
            document.getElementById('viscosityValue').textContent = viscosity;
        });
        
        document.getElementById('particleCountSlider').addEventListener('input', (e) => {
            particleCount = parseInt(e.target.value);
            document.getElementById('particleCountValue').textContent = particleCount;
            initParticles();
        });
        
        document.getElementById('surfaceTensionSlider').addEventListener('input', (e) => {
            surfaceTension = parseFloat(e.target.value);
            document.getElementById('surfaceTensionValue').textContent = surfaceTension;
        });
        
        // 新增控件事件监听器
        document.getElementById('particleSizeSlider').addEventListener('input', (e) => {
            particleSize = parseInt(e.target.value);
            document.getElementById('particleSizeValue').textContent = particleSize;
            
            // 更新现有粒子的大小
            const allParticles = [...particles, ...userCreatedParticles];
            for (const particle of allParticles) {
                particle.radius = particleSize;
            }
        });
        
        document.getElementById('windSlider').addEventListener('input', (e) => {
            windForce = parseFloat(e.target.value);
            document.getElementById('windValue').textContent = windForce;
        });
        
        // 彩虹模式按钮
        document.getElementById('rainbowBtn').addEventListener('click', () => {
            rainbowMode = !rainbowMode;
            const btn = document.getElementById('rainbowBtn');
            
            if (rainbowMode) {
                btn.textContent = '关闭彩虹';
                // 更新所有现有粒子的颜色
                const allParticles = [...particles, ...userCreatedParticles];
                for (const particle of allParticles) {
                    particle.updateColor();
                }
            } else {
                btn.textContent = '彩虹模式';
                // 恢复默认颜色
                const allParticles = [...particles, ...userCreatedParticles];
                for (const particle of allParticles) {
                    particle.updateColor();
                }
            }
        });
        
        // 爆炸效果按钮
        document.getElementById('explosionBtn').addEventListener('click', () => {
            explosionMode = !explosionMode;
            const btn = document.getElementById('explosionBtn');
            
            if (explosionMode) {
                btn.textContent = '关闭爆炸';
                // 创建爆炸效果：在画布中心创建大量粒子向外扩散
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // 确保有足够的粒子槽位
                if (userCreatedParticles.length > MAX_USER_PARTICLES - 100) {
                    userCreatedParticles.splice(0, 100);
                }
                
                // 创建爆炸粒子
                for (let i = 0; i < 100; i++) {
                    const angle = (Math.PI * 2 * i) / 100;
                    const speed = 5 + Math.random() * 10;
                    const particle = new Particle(centerX, centerY);
                    particle.vx = Math.cos(angle) * speed;
                    particle.vy = Math.sin(angle) * speed;
                    particle.updateColor();
                    userCreatedParticles.push(particle);
                }
            } else {
                btn.textContent = '爆炸效果';
            }
        });
        
        // 漩涡效果按钮
        document.getElementById('vortexBtn').addEventListener('click', () => {
            vortexMode = !vortexMode;
            const btn = document.getElementById('vortexBtn');
            
            if (vortexMode) {
                btn.textContent = '关闭漩涡';
                vortexStrength = 5; // 设置漩涡强度
                
                // 更新所有现有粒子的颜色
                const allParticles = [...particles, ...userCreatedParticles];
                for (const particle of allParticles) {
                    particle.updateColor();
                }
                
                // 点击画布设置新的漩涡中心
                canvas.addEventListener('click', setVortexCenter);
            } else {
                btn.textContent = '漩涡效果';
                vortexStrength = 0;
                
                // 移除点击事件监听器
                canvas.removeEventListener('click', setVortexCenter);
            }
        });
        
        // 设置漩涡中心点
        function setVortexCenter(e) {
            if (!vortexMode) return;
            
            const rect = canvas.getBoundingClientRect();
            vortexCenter.x = e.clientX - rect.left;
            vortexCenter.y = e.clientY - rect.top;
            
            // 创建一个视觉指示器显示漩涡中心
            ctx.beginPath();
            ctx.arc(vortexCenter.x, vortexCenter.y, 20, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    </script>
</body>
</html>
