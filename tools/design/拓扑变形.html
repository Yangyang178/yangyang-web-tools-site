<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>拓扑变换：图形在连续变形下的不变性</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary-color: #6366f1;
            --secondary-color: #8b5cf6;
            --accent-color: #ec4899;
            --light-color: #f8fafc;
            --dark-color: #1e293b;
            --text-color: #334155;
            --card-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            --hover-shadow: 0 15px 35px rgba(0, 0, 0, 0.15);
        }
        
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
            min-height: 100vh;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }
        
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="none"/><path d="M0,0 L100,100 M100,0 L0,100" stroke="rgba(99, 102, 241, 0.05)" stroke-width="1"/></svg>');
            z-index: -1;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: var(--card-shadow);
            padding: 40px;
            backdrop-filter: blur(10px);
            animation: fadeIn 0.8s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 40px;
            font-size: 2.8em;
            position: relative;
            padding-bottom: 15px;
        }
        
        h1::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 2px;
        }
        
        h2 {
            color: var(--secondary-color);
            margin-top: 40px;
            margin-bottom: 20px;
            font-size: 2em;
            position: relative;
            padding-left: 20px;
        }
        
        h2::before {
            content: "";
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 30px;
            background: linear-gradient(to bottom, var(--primary-color), var(--secondary-color));
            border-radius: 4px;
        }
        
        h3 {
            color: var(--accent-color);
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
        }
        
        h3::before {
            content: "◆";
            margin-right: 10px;
            color: var(--accent-color);
        }
        
        p {
            margin-bottom: 18px;
            text-align: justify;
            font-size: 1.1em;
            line-height: 1.7;
        }
        
        .canvas-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin: 25px 0;
            gap: 20px;
        }
        
        .canvas-wrapper {
            margin: 15px;
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: var(--card-shadow);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .canvas-wrapper:hover {
            transform: translateY(-5px);
            box-shadow: var(--hover-shadow);
        }
        
        canvas {
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            background-color: white;
            cursor: pointer;
            max-width: 100%;
        }
        
        .controls {
            margin: 25px 0;
            text-align: center;
        }
        
        button {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            padding: 12px 25px;
            margin: 8px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .info-box {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
            border-left: 4px solid var(--primary-color);
            padding: 20px;
            margin: 25px 0;
            border-radius: 0 15px 15px 0;
            position: relative;
            overflow: hidden;
        }
        
        .info-box::before {
            content: "";
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.2) 0%, transparent 70%);
            border-radius: 50%;
        }
        
        .example {
            background-color: white;
            padding: 25px;
            margin: 20px 0;
            border-radius: 15px;
            border: 1px solid #e2e8f0;
            box-shadow: var(--card-shadow);
            transition: all 0.3s ease;
        }
        
        .example:hover {
            box-shadow: var(--hover-shadow);
        }
        
        .slider-container {
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }
        
        input[type="range"] {
            width: 100%;
            margin: 15px 0;
            height: 8px;
            border-radius: 5px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .property-list {
            list-style-type: none;
            padding-left: 20px;
        }
        
        .property-list li {
            margin-bottom: 12px;
            position: relative;
            padding-left: 30px;
            font-size: 1.1em;
        }
        
        .property-list li::before {
            content: "✓";
            color: var(--primary-color);
            font-weight: bold;
            position: absolute;
            left: 0;
            top: 0;
            width: 24px;
            height: 24px;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .highlight {
            background: linear-gradient(120deg, rgba(99, 102, 241, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%);
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .interactive-section {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.05), rgba(139, 92, 246, 0.05));
            padding: 30px;
            border-radius: 15px;
            margin: 25px 0;
            border: 1px solid rgba(99, 102, 241, 0.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .shape-indicator {
            display: inline-block;
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-radius: 20px;
            font-weight: 600;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2.2em;
            }
            
            h2 {
                font-size: 1.7em;
            }
            
            .canvas-container {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>拓扑变换：图形在连续变形下的不变性</h1>
        
        <div class="info-box">
            <p>拓扑学是数学的一个分支，研究的是几何图形在连续变形（如拉伸、扭曲、弯曲，但不撕裂或粘合）下保持不变的性质。在拓扑学中，我们关注的是图形的"连接方式"而非具体的形状或大小。</p>
        </div>
        
        <h2>什么是拓扑变换？</h2>
        <p>拓扑变换是一种特殊的变换，它满足以下条件：</p>
        <ul class="property-list">
            <li><span class="highlight">连续性</span>：变换过程中不能有突然的跳跃或断裂</li>
            <li><span class="highlight">可逆性</span>：变换可以被逆转，恢复到原始状态</li>
            <li><span class="highlight">一一对应</span>：变换前后的点之间存在一一对应关系</li>
        </ul>
        
        <p>直观地说，拓扑变换就像是用弹性极好的橡胶制成的图形，我们可以任意拉伸、弯曲、扭曲它，但不能撕裂它，也不能把不同的部分粘在一起。</p>
        
        <h2>拓扑不变性</h2>
        <p>在拓扑变换下，一些性质保持不变，这些性质称为"拓扑不变性"。以下是一些重要的拓扑不变性：</p>
        
        <div class="example">
            <h3>连通性</h3>
            <p>如果一个图形是连通的（即从图形上的任意一点可以沿着图形到达任意其他点），那么在拓扑变换后，它仍然保持连通。</p>
            
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="connectedCanvas" width="300" height="200"></canvas>
                    <p>连通图形</p>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="disconnectedCanvas" width="300" height="200"></canvas>
                    <p>不连通图形</p>
                </div>
            </div>
        </div>
        
        <div class="example">
            <h3>欧拉示性数</h3>
            <p>对于多面体，欧拉示性数定义为 V - E + F（顶点数 - 边数 + 面数），这是一个拓扑不变量。例如，所有凸多面体的欧拉示性数都是2。</p>
            
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="cubeCanvas" width="300" height="200"></canvas>
                    <p>立方体 (V=8, E=12, F=6, 欧拉示性数=2)</p>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="tetrahedronCanvas" width="300" height="200"></canvas>
                    <p>四面体 (V=4, E=6, F=4, 欧拉示性数=2)</p>
                </div>
            </div>
        </div>
        
        <div class="example">
            <h3>洞的数量</h3>
            <p>图形中"洞"的数量是拓扑不变量。例如，一个球面没有洞，而一个环面（像甜甜圈）有一个洞。</p>
            
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="sphereCanvas" width="300" height="200"></canvas>
                    <p>球面（0个洞）</p>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="torusCanvas" width="300" height="200"></canvas>
                    <p>环面（1个洞）</p>
                </div>
            </div>
        </div>
        
        <div class="example">
            <h3>球面到点状的变换</h3>
            <p>球面可以通过连续变形收缩为一个点，这表明球面是"可收缩"的。这是拓扑学中的一个重要概念。</p>
            
            <div class="interactive-section">
                <canvas id="sphereToPointCanvas" width="600" height="300"></canvas>
                <div class="slider-container">
                    <label for="sphereSlider">变换进度：</label>
                    <input type="range" id="sphereSlider" min="0" max="100" value="0">
                    <span id="sphereValue">0%</span>
                </div>
                <div class="controls">
                    <button id="playSphereBtn">播放变换</button>
                    <button id="resetSphereBtn">重置</button>
                </div>
            </div>
        </div>
        
        <div class="example">
            <h3>莫比乌斯带</h3>
            <p>莫比乌斯带是一个只有一个面和一个边的曲面。它可以通过将一个长条带的一端旋转180度后与另一端粘合而成。</p>
            
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="mobiusStripCanvas" width="300" height="200"></canvas>
                    <p>莫比乌斯带</p>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="normalStripCanvas" width="300" height="200"></canvas>
                    <p>普通环带（两个面）</p>
                </div>
            </div>
        </div>
        
        <div class="example">
            <h3>克莱因瓶</h3>
            <p>克莱因瓶是一个没有边界的曲面，它只有一个面，且无法在三维空间中自相交地构造出来。它是拓扑学中一个非常有趣的例子。</p>
            
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="kleinBottleCanvas" width="300" height="200"></canvas>
                    <p>克莱因瓶（三维投影）</p>
                </div>
            </div>
        </div>
        
        <div class="example">
            <h3>圆柱到圆锥的变换</h3>
            <p>圆柱可以通过连续变形变成圆锥，这是一个简单的拓扑变换示例。</p>
            
            <div class="interactive-section">
                <canvas id="cylinderToConeCanvas" width="600" height="300"></canvas>
                <div class="slider-container">
                    <label for="cylinderSlider">变换进度：</label>
                    <input type="range" id="cylinderSlider" min="0" max="100" value="0">
                    <span id="cylinderValue">0%</span>
                </div>
                <div class="controls">
                    <button id="playCylinderBtn">播放变换</button>
                    <button id="resetCylinderBtn">重置</button>
                </div>
            </div>
        </div>
        
        <div class="example">
            <h3>矩形到圆柱的变换</h3>
            <p>一个矩形可以通过将两条对边粘合而变成一个圆柱，这是构造拓扑空间的基本方法之一。</p>
            
            <div class="interactive-section">
                <canvas id="rectangleToCylinderCanvas" width="600" height="300"></canvas>
                <div class="slider-container">
                    <label for="rectangleSlider">变换进度：</label>
                    <input type="range" id="rectangleSlider" min="0" max="100" value="0">
                    <span id="rectangleValue">0%</span>
                </div>
                <div class="controls">
                    <button id="playRectangleBtn">播放变换</button>
                    <button id="resetRectangleBtn">重置</button>
                </div>
            </div>
        </div>
        
        <h2>经典拓扑变换示例</h2>
        
        <div class="example">
            <h3>圆环到咖啡杯的变换</h3>
            <p>这是拓扑学中最著名的例子之一：一个圆环（甜甜圈）可以连续变形为一个咖啡杯，因为它们都有一个洞。</p>
            
            <div class="interactive-section">
                <canvas id="donutToCupCanvas" width="600" height="300"></canvas>
                <div class="slider-container">
                    <label for="transformSlider">变换进度：</label>
                    <input type="range" id="transformSlider" min="0" max="100" value="0">
                    <span id="transformValue">0%</span>
                </div>
                <div class="controls">
                    <button id="playTransformBtn">播放变换</button>
                    <button id="resetTransformBtn">重置</button>
                </div>
            </div>
        </div>
        
        <div class="example">
            <h3>交互式拓扑变形</h3>
            <p>在下方的画布中，您可以拖动点来变形图形。注意，无论您如何变形，只要不撕裂或粘合，图形的拓扑性质（如连通性、洞的数量）将保持不变。</p>
            
            <div class="interactive-section">
                <canvas id="interactiveCanvas" width="600" height="400"></canvas>
                <div class="controls">
                    <button id="resetInteractiveBtn">重置图形</button>
                    <button id="changeShapeBtn">切换形状</button>
                </div>
                <p>当前形状：<span id="currentShape" class="shape-indicator">圆环</span></p>
            </div>
        </div>
        
        <h2>拓扑学的应用</h2>
        <p>拓扑学在许多领域都有重要应用：</p>
        <ul class="property-list">
            <li>物理学中的弦理论和广义相对论</li>
            <li>计算机科学中的网络拓扑和数据分析</li>
            <li>生物学中的DNA结构和蛋白质折叠</li>
            <li>工程学中的电路设计和结构分析</li>
        </ul>
        
        <div class="info-box">
            <p>通过这个交互式演示，希望您能更好地理解拓扑变换和拓扑不变性的概念。记住，在拓扑学中，我们关注的是图形的"本质连接方式"，而不是具体的形状或大小。</p>
        </div>
    </div>

    <script>
        // 连通图形示例
        function drawConnectedShapes() {
            const connectedCanvas = document.getElementById('connectedCanvas');
            const connectedCtx = connectedCanvas.getContext('2d');
            
            // 绘制连通图形
            connectedCtx.beginPath();
            connectedCtx.arc(150, 100, 60, 0, Math.PI * 2);
            connectedCtx.strokeStyle = '#3498db';
            connectedCtx.lineWidth = 3;
            connectedCtx.stroke();
            
            connectedCtx.beginPath();
            connectedCtx.moveTo(150, 40);
            connectedCtx.lineTo(150, 160);
            connectedCtx.stroke();
            
            connectedCtx.beginPath();
            connectedCtx.moveTo(90, 100);
            connectedCtx.lineTo(210, 100);
            connectedCtx.stroke();
            
            // 绘制不连通图形
            const disconnectedCanvas = document.getElementById('disconnectedCanvas');
            const disconnectedCtx = disconnectedCanvas.getContext('2d');
            
            disconnectedCtx.beginPath();
            disconnectedCtx.arc(100, 100, 40, 0, Math.PI * 2);
            disconnectedCtx.strokeStyle = '#e74c3c';
            disconnectedCtx.lineWidth = 3;
            disconnectedCtx.stroke();
            
            disconnectedCtx.beginPath();
            disconnectedCtx.arc(200, 100, 40, 0, Math.PI * 2);
            disconnectedCtx.stroke();
        }
        
        // 多面体示例
        function drawPolyhedrons() {
            // 立方体
            const cubeCanvas = document.getElementById('cubeCanvas');
            const cubeCtx = cubeCanvas.getContext('2d');
            
            cubeCtx.strokeStyle = '#3498db';
            cubeCtx.lineWidth = 2;
            
            // 前面
            cubeCtx.beginPath();
            cubeCtx.rect(100, 50, 100, 100);
            cubeCtx.stroke();
            
            // 后面
            cubeCtx.beginPath();
            cubeCtx.rect(130, 30, 100, 100);
            cubeCtx.stroke();
            
            // 连接线
            cubeCtx.beginPath();
            cubeCtx.moveTo(100, 50);
            cubeCtx.lineTo(130, 30);
            cubeCtx.moveTo(200, 50);
            cubeCtx.lineTo(230, 30);
            cubeCtx.moveTo(100, 150);
            cubeCtx.lineTo(130, 130);
            cubeCtx.moveTo(200, 150);
            cubeCtx.lineTo(230, 130);
            cubeCtx.stroke();
            
            // 四面体
            const tetrahedronCanvas = document.getElementById('tetrahedronCanvas');
            const tetrahedronCtx = tetrahedronCanvas.getContext('2d');
            
            tetrahedronCtx.strokeStyle = '#2ecc71';
            tetrahedronCtx.lineWidth = 2;
            
            // 底面
            tetrahedronCtx.beginPath();
            tetrahedronCtx.moveTo(150, 150);
            tetrahedronCtx.lineTo(100, 150);
            tetrahedronCtx.lineTo(125, 100);
            tetrahedronCtx.closePath();
            tetrahedronCtx.stroke();
            
            // 顶点
            tetrahedronCtx.beginPath();
            tetrahedronCtx.moveTo(150, 150);
            tetrahedronCtx.lineTo(125, 50);
            tetrahedronCtx.moveTo(100, 150);
            tetrahedronCtx.lineTo(125, 50);
            tetrahedronCtx.moveTo(125, 100);
            tetrahedronCtx.lineTo(125, 50);
            tetrahedronCtx.stroke();
        }
        
        // 球面和环面示例
        function drawSphereAndTorus() {
            // 球面
            const sphereCanvas = document.getElementById('sphereCanvas');
            const sphereCtx = sphereCanvas.getContext('2d');
            
            sphereCtx.strokeStyle = '#3498db';
            sphereCtx.lineWidth = 2;
            
            sphereCtx.beginPath();
            sphereCtx.arc(150, 100, 70, 0, Math.PI * 2);
            sphereCtx.stroke();
            
            sphereCtx.beginPath();
            sphereCtx.arc(150, 100, 70, 0, Math.PI);
            sphereCtx.setLineDash([5, 3]);
            sphereCtx.stroke();
            sphereCtx.setLineDash([]);
            
            // 环面
            const torusCanvas = document.getElementById('torusCanvas');
            const torusCtx = torusCanvas.getContext('2d');
            
            torusCtx.strokeStyle = '#e74c3c';
            torusCtx.lineWidth = 2;
            
            // 外圆
            torusCtx.beginPath();
            torusCtx.arc(150, 100, 70, 0, Math.PI * 2);
            torusCtx.stroke();
            
            // 内圆
            torusCtx.beginPath();
            torusCtx.arc(150, 100, 30, 0, Math.PI * 2);
            torusCtx.stroke();
            
            // 连接线
            torusCtx.beginPath();
            torusCtx.moveTo(220, 100);
            torusCtx.lineTo(180, 100);
            torusCtx.moveTo(80, 100);
            torusCtx.lineTo(120, 100);
            torusCtx.stroke();
        }
        
        // 球面到点状的变换
        let sphereAnimation = null;
        let sphereProgress = 0;
        
        function drawSphereToPoint(progress) {
            const canvas = document.getElementById('sphereToPointCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = 100;
            
            // 根据进度计算半径
            const radius = maxRadius * (1 - progress / 100);
            
            // 绘制球面
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // 绘制经线
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, radius, radius * Math.sin(angle), 0, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // 绘制纬线
            for (let i = 1; i < 4; i++) {
                const y = centerY - radius + (2 * radius * i / 4);
                const r = Math.sqrt(radius * radius - Math.pow(y - centerY, 2));
                
                ctx.beginPath();
                ctx.ellipse(centerX, y, r, r * 0.3, 0, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // 当接近点状时，绘制一个点
            if (radius < 5) {
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 莫比乌斯带和普通环带
        function drawMobiusStrips() {
            // 莫比乌斯带
            const mobiusCanvas = document.getElementById('mobiusStripCanvas');
            const mobiusCtx = mobiusCanvas.getContext('2d');
            
            mobiusCtx.strokeStyle = '#9b59b6';
            mobiusCtx.lineWidth = 2;
            
            // 绘制莫比乌斯带
            const centerX = 150;
            const centerY = 100;
            const radiusX = 80;
            const radiusY = 30;
            
            mobiusCtx.beginPath();
            for (let t = 0; t <= Math.PI * 2; t += 0.1) {
                const x = centerX + radiusX * Math.cos(t);
                const y = centerY + radiusY * Math.sin(t) * Math.cos(t / 2);
                const z = radiusY * Math.sin(t) * Math.sin(t / 2);
                
                // 简单的3D投影
                const scale = 1 / (1 + z / 200);
                const projX = centerX + (x - centerX) * scale;
                const projY = centerY + (y - centerY) * scale;
                
                if (t === 0) {
                    mobiusCtx.moveTo(projX, projY);
                } else {
                    mobiusCtx.lineTo(projX, projY);
                }
            }
            mobiusCtx.closePath();
            mobiusCtx.stroke();
            
            // 绘制中心线
            mobiusCtx.setLineDash([5, 3]);
            mobiusCtx.beginPath();
            for (let t = 0; t <= Math.PI * 2; t += 0.1) {
                const x = centerX + radiusX * Math.cos(t);
                const y = centerY + radiusY * Math.sin(t) * Math.cos(t / 2);
                const z = radiusY * Math.sin(t) * Math.sin(t / 2);
                
                const scale = 1 / (1 + z / 200);
                const projX = centerX + (x - centerX) * scale;
                const projY = centerY + (y - centerY) * scale;
                
                if (t === 0) {
                    mobiusCtx.moveTo(projX, projY);
                } else {
                    mobiusCtx.lineTo(projX, projY);
                }
            }
            mobiusCtx.stroke();
            mobiusCtx.setLineDash([]);
            
            // 普通环带
            const normalCanvas = document.getElementById('normalStripCanvas');
            const normalCtx = normalCanvas.getContext('2d');
            
            normalCtx.strokeStyle = '#2ecc71';
            normalCtx.lineWidth = 2;
            
            // 绘制普通环带
            normalCtx.beginPath();
            normalCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
            normalCtx.stroke();
            
            // 绘制内椭圆
            normalCtx.beginPath();
            normalCtx.ellipse(centerX, centerY, radiusX * 0.7, radiusY * 0.7, 0, 0, Math.PI * 2);
            normalCtx.stroke();
        }
        
        // 克莱因瓶
        function drawKleinBottle() {
            const canvas = document.getElementById('kleinBottleCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            
            const centerX = 150;
            const centerY = 100;
            
            // 绘制克莱因瓶的简化表示
            // 底部圆环
            ctx.beginPath();
            ctx.ellipse(centerX, centerY + 30, 60, 20, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // 顶部圆环
            ctx.beginPath();
            ctx.ellipse(centerX, centerY - 30, 60, 20, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // 连接部分
            ctx.beginPath();
            ctx.moveTo(centerX - 60, centerY + 30);
            ctx.lineTo(centerX - 60, centerY - 30);
            ctx.moveTo(centerX + 60, centerY + 30);
            ctx.lineTo(centerX + 60, centerY - 30);
            ctx.stroke();
            
            // 自相交部分
            ctx.beginPath();
            ctx.ellipse(centerX + 30, centerY, 40, 15, Math.PI / 4, 0, Math.PI * 2);
            ctx.stroke();
            
            // 标注
            ctx.fillStyle = '#e74c3c';
            ctx.font = '12px Arial';
            ctx.fillText('自相交处', centerX + 40, centerY);
        }
        
        // 圆柱到圆锥的变换
        let cylinderAnimation = null;
        let cylinderProgress = 0;
        
        function drawCylinderToCone(progress) {
            const canvas = document.getElementById('cylinderToConeCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#16a085';
            ctx.lineWidth = 3;
            
            const centerX = canvas.width / 2;
            const bottomY = canvas.height - 50;
            const topY = 50;
            const radius = 80;
            
            // 根据进度计算顶部半径
            const topRadius = radius * (1 - progress / 100);
            
            // 绘制底部椭圆
            ctx.beginPath();
            ctx.ellipse(centerX, bottomY, radius, radius * 0.3, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // 绘制顶部椭圆
            ctx.beginPath();
            ctx.ellipse(centerX, topY, topRadius, topRadius * 0.3, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // 绘制连接线
            ctx.beginPath();
            ctx.moveTo(centerX - radius, bottomY);
            ctx.lineTo(centerX - topRadius, topY);
            ctx.moveTo(centerX + radius, bottomY);
            ctx.lineTo(centerX + topRadius, topY);
            ctx.stroke();
            
            // 绘制中心线（虚线）
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(centerX, bottomY);
            ctx.lineTo(centerX, topY);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // 矩形到圆柱的变换
        let rectangleAnimation = null;
        let rectangleProgress = 0;
        
        function drawRectangleToCylinder(progress) {
            const canvas = document.getElementById('rectangleToCylinderCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 3;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const width = 200;
            const height = 150;
            const radius = width / (2 * Math.PI);
            
            if (progress < 50) {
                // 矩形阶段
                const rectProgress = progress / 50;
                
                // 绘制矩形
                ctx.beginPath();
                ctx.rect(centerX - width/2, centerY - height/2, width, height);
                ctx.stroke();
                
                // 绘制将要粘合的边
                ctx.strokeStyle = '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(centerX - width/2, centerY - height/2);
                ctx.lineTo(centerX - width/2, centerY + height/2);
                ctx.moveTo(centerX + width/2, centerY - height/2);
                ctx.lineTo(centerX + width/2, centerY + height/2);
                ctx.stroke();
                
                // 绘制箭头表示粘合方向
                if (rectProgress > 0.3) {
                    const arrowY = centerY;
                    const arrowSize = 10 * Math.min(1, (rectProgress - 0.3) / 0.2);
                    
                    ctx.strokeStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.moveTo(centerX - width/2 - 20, arrowY);
                    ctx.lineTo(centerX - width/2 - 5, arrowY);
                    ctx.moveTo(centerX - width/2 - 5, arrowY);
                    ctx.lineTo(centerX - width/2 - 5 - arrowSize, arrowY - arrowSize);
                    ctx.moveTo(centerX - width/2 - 5, arrowY);
                    ctx.lineTo(centerX - width/2 - 5 - arrowSize, arrowY + arrowSize);
                    
                    ctx.moveTo(centerX + width/2 + 20, arrowY);
                    ctx.lineTo(centerX + width/2 + 5, arrowY);
                    ctx.moveTo(centerX + width/2 + 5, arrowY);
                    ctx.lineTo(centerX + width/2 + 5 + arrowSize, arrowY - arrowSize);
                    ctx.moveTo(centerX + width/2 + 5, arrowY);
                    ctx.lineTo(centerX + width/2 + 5 + arrowSize, arrowY + arrowSize);
                    ctx.stroke();
                }
            } else {
                // 圆柱阶段
                const cylinderProgress = (progress - 50) / 50;
                
                // 绘制圆柱
                const cylinderHeight = height * cylinderProgress;
                const cylinderY = centerY + (height - cylinderHeight) / 2;
                
                // 底部椭圆
                ctx.beginPath();
                ctx.ellipse(centerX, cylinderY + cylinderHeight, radius, radius * 0.3, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // 顶部椭圆
                ctx.beginPath();
                ctx.ellipse(centerX, cylinderY, radius, radius * 0.3, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // 连接线
                ctx.beginPath();
                ctx.moveTo(centerX - radius, cylinderY);
                ctx.lineTo(centerX - radius, cylinderY + cylinderHeight);
                ctx.moveTo(centerX + radius, cylinderY);
                ctx.lineTo(centerX + radius, cylinderY + cylinderHeight);
                ctx.stroke();
                
                // 标记粘合线
                if (cylinderProgress > 0.5) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.setLineDash([5, 3]);
                    ctx.beginPath();
                    ctx.moveTo(centerX + radius, cylinderY);
                    ctx.lineTo(centerX + radius, cylinderY + cylinderHeight);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        // 圆环到咖啡杯的变换
        let transformAnimation = null;
        let transformProgress = 0;
        
        function drawDonutToCup(progress) {
            const canvas = document.getElementById('donutToCupCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 3;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            if (progress < 50) {
                // 圆环阶段
                const outerRadius = 80;
                const innerRadius = 30;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                // 变形为咖啡杯
                const t = (progress - 50) / 50;
                
                // 杯身
                ctx.beginPath();
                ctx.moveTo(centerX - 60, centerY - 40);
                ctx.lineTo(centerX - 60, centerY + 40);
                ctx.lineTo(centerX + 60, centerY + 40);
                ctx.lineTo(centerX + 60, centerY - 40);
                ctx.stroke();
                
                // 杯口
                ctx.beginPath();
                ctx.ellipse(centerX, centerY - 40, 60, 10, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // 杯把手（变形后的洞）
                const handleSize = 30 * (1 - t) + 20 * t;
                const handleX = centerX + 60 + 20 * t;
                const handleY = centerY - 20;
                
                ctx.beginPath();
                ctx.arc(handleX, handleY, handleSize, 0, Math.PI * 2);
                ctx.stroke();
                
                // 连接线
                ctx.beginPath();
                ctx.moveTo(centerX + 60, centerY - 20);
                ctx.lineTo(handleX - handleSize, handleY);
                ctx.moveTo(centerX + 60, centerY);
                ctx.lineTo(handleX - handleSize, handleY);
                ctx.stroke();
            }
        }
        
        // 交互式拓扑变形
        let interactivePoints = [];
        let isDragging = false;
        let dragIndex = -1;
        
        function startDrag(e) {
            const rect = document.getElementById('interactiveCanvas').getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 检查是否点击了控制点
            for (let i = 0; i < interactivePoints.length; i++) {
                const dx = x - interactivePoints[i].x;
                const dy = y - interactivePoints[i].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 10) {
                    isDragging = true;
                    dragIndex = i;
                    break;
                }
            }
        }
        
        function drag(e) {
            if (isDragging && dragIndex >= 0) {
                const rect = document.getElementById('interactiveCanvas').getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                interactivePoints[dragIndex].x = x;
                interactivePoints[dragIndex].y = y;
                
                drawInteractiveShape();
            }
        }
        
        function endDrag() {
            isDragging = false;
            dragIndex = -1;
        }
        
        function resetInteractiveShape() {
            const shapeIndicator = document.querySelector('.shape-indicator');
            
            if (currentShapeType === 'torus') {
                shapeIndicator.textContent = '圆环';
                
                // 重置圆环控制点
                interactivePoints = [];
                const centerX = 200;
                const centerY = 150;
                const outerRadius = 100;
                const innerRadius = 50;
                
                // 外圆控制点
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * outerRadius;
                    const y = centerY + Math.sin(angle) * outerRadius;
                    interactivePoints.push({x, y});
                }
                
                // 内圆控制点
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * innerRadius;
                    const y = centerY + Math.sin(angle) * innerRadius;
                    interactivePoints.push({x, y});
                }
            } else {
                shapeIndicator.textContent = '8字形';
                
                // 重置8字形控制点
                interactivePoints = [];
                const centerX = 200;
                const centerY = 150;
                const radius = 80;
                
                // 创建8字形的控制点
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    let x, y;
                    
                    if (i < 8) {
                        // 上半圆
                        x = centerX + Math.cos(angle) * radius;
                        y = centerY + Math.sin(angle) * radius / 2 - radius / 2;
                    } else {
                        // 下半圆
                        x = centerX + Math.cos(angle) * radius;
                        y = centerY + Math.sin(angle) * radius / 2 + radius / 2;
                    }
                    
                    interactivePoints.push({x, y});
                }
            }
            
            drawInteractiveShape();
        }

        let currentShapeType = 'torus'; // 'torus' 或 'figure8'
        
        function initInteractiveCanvas() {
    const shapeIndicator = document.querySelector('.shape-indicator');
    shapeIndicator.textContent = '圆环';
    
    const canvas = document.getElementById('interactiveCanvas');
    const ctx = canvas.getContext('2d');
    
    // 初始化圆环的点
    interactivePoints = [];
    const centerX = 200;
    const centerY = 150;
    const outerRadius = 100;
    const innerRadius = 50;
    
    // 外圆控制点
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const x = centerX + Math.cos(angle) * outerRadius;
        const y = centerY + Math.sin(angle) * outerRadius;
        interactivePoints.push({x, y});
    }
    
    // 内圆控制点
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const x = centerX + Math.cos(angle) * innerRadius;
        const y = centerY + Math.sin(angle) * innerRadius;
        interactivePoints.push({x, y});
    }
    
    // 初始化当前形状类型
    currentShapeType = 'torus';
    
    drawInteractiveShape();
}
        
        function drawInteractiveShape() {
            const canvas = document.getElementById('interactiveCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#16a085';
            ctx.lineWidth = 2;
            
            if (currentShapeType === 'torus') {
                const numPoints = interactivePoints.length / 2;
                
                // 绘制外圆
                ctx.beginPath();
                for (let i = 0; i < numPoints; i++) {
                    if (i === 0) {
                        ctx.moveTo(interactivePoints[i].x, interactivePoints[i].y);
                    } else {
                        ctx.lineTo(interactivePoints[i].x, interactivePoints[i].y);
                    }
                }
                ctx.closePath();
                ctx.stroke();
                
                // 绘制内圆
                ctx.beginPath();
                for (let i = numPoints; i < interactivePoints.length; i++) {
                    if (i === numPoints) {
                        ctx.moveTo(interactivePoints[i].x, interactivePoints[i].y);
                    } else {
                        ctx.lineTo(interactivePoints[i].x, interactivePoints[i].y);
                    }
                }
                ctx.closePath();
                ctx.stroke();
                
                // 绘制连接线
                for (let i = 0; i < 4; i++) {
                    const idx = Math.floor(i * numPoints / 4);
                    ctx.beginPath();
                    ctx.moveTo(interactivePoints[idx].x, interactivePoints[idx].y);
                    ctx.lineTo(interactivePoints[idx + numPoints].x, interactivePoints[idx + numPoints].y);
                    ctx.stroke();
                }
            } else {
                // 绘制8字形
                ctx.beginPath();
                for (let i = 0; i < interactivePoints.length; i++) {
                    if (i === 0) {
                        ctx.moveTo(interactivePoints[i].x, interactivePoints[i].y);
                    } else {
                        ctx.lineTo(interactivePoints[i].x, interactivePoints[i].y);
                    }
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            // 绘制控制点
            ctx.fillStyle = '#e74c3c';
            for (let i = 0; i < interactivePoints.length; i++) {
                ctx.beginPath();
                ctx.arc(interactivePoints[i].x, interactivePoints[i].y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function changeShape() {
            const shapeIndicator = document.querySelector('.shape-indicator');
            
            if (currentShapeType === 'torus') {
                currentShapeType = 'figure8';
                shapeIndicator.textContent = '8字形';
                
                // 创建8字形控制点
                interactivePoints = [];
                const centerX = 200;
                const centerY = 150;
                const radius = 80;
                
                // 创建8字形的控制点
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    let x, y;
                    
                    if (i < 8) {
                        // 上半圆
                        x = centerX + Math.cos(angle) * radius;
                        y = centerY + Math.sin(angle) * radius / 2 - radius / 2;
                    } else {
                        // 下半圆
                        x = centerX + Math.cos(angle) * radius;
                        y = centerY + Math.sin(angle) * radius / 2 + radius / 2;
                    }
                    
                    interactivePoints.push({x, y});
                }
            } else {
                currentShapeType = 'torus';
                shapeIndicator.textContent = '圆环';
                
                // 创建圆环控制点
                interactivePoints = [];
                const centerX = 200;
                const centerY = 150;
                const outerRadius = 100;
                const innerRadius = 50;
                
                // 外圆控制点
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * outerRadius;
                    const y = centerY + Math.sin(angle) * outerRadius;
                    interactivePoints.push({x, y});
                }
                
                // 内圆控制点
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * innerRadius;
                    const y = centerY + Math.sin(angle) * innerRadius;
                    interactivePoints.push({x, y});
                }
            }
            
            drawInteractiveShape();
        }
        
        // 事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            // 初始化所有画布
            drawConnectedShapes();
            drawPolyhedrons();
            drawSphereAndTorus();
            drawMobiusStrips();
            drawKleinBottle();
            initInteractiveCanvas();
            drawDonutToCup(0);
            drawSphereToPoint(0);
            drawCylinderToCone(0);
            drawRectangleToCylinder(0);
            
            // 圆环到咖啡杯变换的滑块
            const transformSlider = document.getElementById('transformSlider');
            const transformValue = document.getElementById('transformValue');
            
            transformSlider.addEventListener('input', function() {
                transformProgress = parseInt(this.value);
                transformValue.textContent = transformProgress + '%';
                drawDonutToCup(transformProgress);
            });
            
            // 播放变换按钮
            document.getElementById('playTransformBtn').addEventListener('click', function() {
                if (transformAnimation) {
                    clearInterval(transformAnimation);
                    transformAnimation = null;
                    this.textContent = '播放变换';
                } else {
                    this.textContent = '暂停变换';
                    transformAnimation = setInterval(function() {
                        transformProgress += 1;
                        if (transformProgress > 100) {
                            transformProgress = 0;
                        }
                        transformSlider.value = transformProgress;
                        transformValue.textContent = transformProgress + '%';
                        drawDonutToCup(transformProgress);
                    }, 50);
                }
            });
            
            // 重置变换按钮
            document.getElementById('resetTransformBtn').addEventListener('click', function() {
                if (transformAnimation) {
                    clearInterval(transformAnimation);
                    transformAnimation = null;
                    document.getElementById('playTransformBtn').textContent = '播放变换';
                }
                transformProgress = 0;
                transformSlider.value = 0;
                transformValue.textContent = '0%';
                drawDonutToCup(0);
            });
            
            // 球面到点状变换的滑块
            const sphereSlider = document.getElementById('sphereSlider');
            const sphereValue = document.getElementById('sphereValue');
            
            sphereSlider.addEventListener('input', function() {
                sphereProgress = parseInt(this.value);
                sphereValue.textContent = sphereProgress + '%';
                drawSphereToPoint(sphereProgress);
            });
            
            // 播放球面变换按钮
            document.getElementById('playSphereBtn').addEventListener('click', function() {
                if (sphereAnimation) {
                    clearInterval(sphereAnimation);
                    sphereAnimation = null;
                    this.textContent = '播放变换';
                } else {
                    this.textContent = '暂停变换';
                    sphereAnimation = setInterval(function() {
                        sphereProgress += 1;
                        if (sphereProgress > 100) {
                            sphereProgress = 0;
                        }
                        sphereSlider.value = sphereProgress;
                        sphereValue.textContent = sphereProgress + '%';
                        drawSphereToPoint(sphereProgress);
                    }, 50);
                }
            });
            
            // 重置球面变换按钮
            document.getElementById('resetSphereBtn').addEventListener('click', function() {
                if (sphereAnimation) {
                    clearInterval(sphereAnimation);
                    sphereAnimation = null;
                    document.getElementById('playSphereBtn').textContent = '播放变换';
                }
                sphereProgress = 0;
                sphereSlider.value = 0;
                sphereValue.textContent = '0%';
                drawSphereToPoint(0);
            });
            
            // 圆柱到圆锥变换的滑块
            const cylinderSlider = document.getElementById('cylinderSlider');
            const cylinderValue = document.getElementById('cylinderValue');
            
            cylinderSlider.addEventListener('input', function() {
                cylinderProgress = parseInt(this.value);
                cylinderValue.textContent = cylinderProgress + '%';
                drawCylinderToCone(cylinderProgress);
            });
            
            // 播放圆柱变换按钮
            document.getElementById('playCylinderBtn').addEventListener('click', function() {
                if (cylinderAnimation) {
                    clearInterval(cylinderAnimation);
                    cylinderAnimation = null;
                    this.textContent = '播放变换';
                } else {
                    this.textContent = '暂停变换';
                    cylinderAnimation = setInterval(function() {
                        cylinderProgress += 1;
                        if (cylinderProgress > 100) {
                            cylinderProgress = 0;
                        }
                        cylinderSlider.value = cylinderProgress;
                        cylinderValue.textContent = cylinderProgress + '%';
                        drawCylinderToCone(cylinderProgress);
                    }, 50);
                }
            });
            
            // 重置圆柱变换按钮
            document.getElementById('resetCylinderBtn').addEventListener('click', function() {
                if (cylinderAnimation) {
                    clearInterval(cylinderAnimation);
                    cylinderAnimation = null;
                    document.getElementById('playCylinderBtn').textContent = '播放变换';
                }
                cylinderProgress = 0;
                cylinderSlider.value = 0;
                cylinderValue.textContent = '0%';
                drawCylinderToCone(0);
            });
            
            // 矩形到圆柱变换的滑块
            const rectangleSlider = document.getElementById('rectangleSlider');
            const rectangleValue = document.getElementById('rectangleValue');
            
            rectangleSlider.addEventListener('input', function() {
                rectangleProgress = parseInt(this.value);
                rectangleValue.textContent = rectangleProgress + '%';
                drawRectangleToCylinder(rectangleProgress);
            });
            
            // 播放矩形变换按钮
            document.getElementById('playRectangleBtn').addEventListener('click', function() {
                if (rectangleAnimation) {
                    clearInterval(rectangleAnimation);
                    rectangleAnimation = null;
                    this.textContent = '播放变换';
                } else {
                    this.textContent = '暂停变换';
                    rectangleAnimation = setInterval(function() {
                        rectangleProgress += 1;
                        if (rectangleProgress > 100) {
                            rectangleProgress = 0;
                        }
                        rectangleSlider.value = rectangleProgress;
                        rectangleValue.textContent = rectangleProgress + '%';
                        drawRectangleToCylinder(rectangleProgress);
                    }, 50);
                }
            });
            
            // 重置矩形变换按钮
            document.getElementById('resetRectangleBtn').addEventListener('click', function() {
                if (rectangleAnimation) {
                    clearInterval(rectangleAnimation);
                    rectangleAnimation = null;
                    document.getElementById('playRectangleBtn').textContent = '播放变换';
                }
                rectangleProgress = 0;
                rectangleSlider.value = 0;
                rectangleValue.textContent = '0%';
                drawRectangleToCylinder(0);
            });
            
            // 交互式画布的鼠标事件
            const interactiveCanvas = document.getElementById('interactiveCanvas');
            
            interactiveCanvas.addEventListener('mousedown', startDrag);
            interactiveCanvas.addEventListener('mousemove', drag);
            interactiveCanvas.addEventListener('mouseup', endDrag);
            interactiveCanvas.addEventListener('mouseleave', endDrag);
            
            // 重置交互式图形按钮
            document.getElementById('resetInteractiveBtn').addEventListener('click', resetInteractiveShape);
            
            // 切换形状按钮
            document.getElementById('changeShapeBtn').addEventListener('click', changeShape);
        });
    </script>
</body>
</html>
